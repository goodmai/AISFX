# Стандарты Разработки и Лучшие Практики (AISFX)

Этот документ описывает стандарты кодирования и архитектурные принципы, которым необходимо следовать при разработке приложения AISFX. Цель — обеспечить чистоту, читаемость, поддерживаемость и масштабируемость кодовой базы.

## 1. Общие Принципы

* **Язык:** Scala 3.
* **Стиль Кода:** Следовать официальному [Scala Style Guide](https://docs.scala-lang.org/style/). Использовать автоматическое форматирование (например, Scalafmt) для единообразия.
* **Неизменяемость (Immutability):** Предпочитать неизменяемые структуры данных (`val`, `List`, `Map`, `Set`, case классы) везде, где это возможно. Использовать `var` и изменяемые коллекции только при явной необходимости и с осторожностью, инкапсулируя изменяемое состояние.
* **Чистые Функции:** Стремиться к написанию чистых функций (без побочных эффектов), где это применимо, особенно в утилитах и сервисах обработки данных.
* **Модульность и Разделение Ответственности (Separation of Concerns):**
    * Придерживаться MVC-подобной архитектуры (View, Controller, Model, Service, Repository, Manager).
    * Каждый класс или объект должен иметь четко определенную, единственную ответственность (Single Responsibility Principle).
    * Использовать менеджеры (`manager/`) для инкапсуляции сложной логики, координирующей работу сервисов и моделей.
    * Использовать сервисы (`service/`) для взаимодействия с внешними системами (API, файловая система, Preferences).
    * Использовать репозитории (`repository/`) для абстракции хранения данных.
    * Использовать утилиты (`util/`) для вспомогательных, переиспользуемых функций.
* **Обработка Ошибок:**
    * Использовать `Try`, `Either` или `Option` для явной обработки возможных ошибок и отсутствия значений. Избегать прямого использования `null` и выбрасывания неконтролируемых исключений в бизнес-логике.
    * Предоставлять информативные сообщения об ошибках.
    * Логировать ошибки с достаточным контекстом.
* **Асинхронность:** Использовать Pekko Actors или `scala.concurrent.Future` для асинхронных операций (взаимодействие с API, длительные вычисления). Обеспечить корректную обработку контекста выполнения (`ExecutionContext`).
* **Тестирование:** Поощряется написание модульных (unit) и интеграционных тестов (хотя в данном запросе не требуется их создание).

## 2. Структура Проекта

* Использовать стандартную структуру пакетов Maven/SBT (`src/main/scala`, `src/main/resources`, `src/test/scala`).
* Организовывать классы по функциональным пакетам (`com.aiplatform.app`, `com.aiplatform.controller`, `com.aiplatform.model`, `com.aiplatform.service`, `com.aiplatform.repository`, `com.aiplatform.view`, `com.aiplatform.util`).

## 3. Именование

* **Классы и Объекты:** `CamelCase` (например, `MainController`, `JsonUtil`).
* **Методы и Переменные:** `camelCase` (например, `loadState`, `activeTopicId`).
* **Константы:** `SCREAMING_SNAKE_CASE` (например, `API_KEY_PREF_KEY`) или `CamelCase` для `val` в объектах.
* **Пакеты:** `lowercase.dot.notation` (например, `com.aiplatform.controller.manager`).
* Использовать осмысленные и описательные имена.

## 4. Ограничения и Соглашения

* **Размер Класса:** Стараться не превышать **500 строк кода** на класс/объект. Если класс становится слишком большим, рассмотреть возможность его разделения или вынесения части логики в хелперы/менеджеры.
* **Длина Строки:** Ограничивать длину строки кода (например, 120 символами) для улучшения читаемости. Использовать Scalafmt для автоматического контроля.
* **Документация:** Добавлять Scaladoc комментарии к публичным классам, методам и сложным участкам кода.
* **Логирование:** Использовать SLF4j с Logback для логирования.
    * `DEBUG`: Для подробной отладочной информации.
    * `INFO`: Для ключевых событий жизненного цикла и важных операций.
    * `WARN`: Для потенциальных проблем или некритичных ошибок.
    * `ERROR`: Для серьезных ошибок, влияющих на работу приложения.
* **Зависимости:** Минимизировать количество внешних зависимостей.

## 5. UI (ScalaFX)

* Четко разделять UI компоненты (`Header`, `Footer`, `HistoryPanel`, `ResponseArea`, `SettingsView`).
* Избегать размещения сложной бизнес-логики непосредственно в классах View. Использовать контроллер для обработки событий UI и обновления View.
* Использовать CSS для стилизации (`main.css`). Минимизировать использование инлайн-стилей.
* Обеспечивать отзывчивость UI, выполняя длительные операции (например, AI запросы) асинхронно вне основного потока JavaFX (`Platform.runLater` использовать только для обновления UI).
* Использовать байндинги (`bind`, `onChange`) для реактивного обновления UI, где это уместно.

## 6. Управление Состоянием

* Использовать централизованный `StateManager` для управления `AppState`.
* Обновления состояния должны быть атомарными и потокобезопасными (`AtomicReference`, `compareAndSet`).
* Сохранять состояние через `StateRepository` после успешных обновлений.