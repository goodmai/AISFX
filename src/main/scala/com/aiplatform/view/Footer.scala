// src/main/scala/com/aiplatform/view/Footer.scala
package com.aiplatform.view

import scalafx.Includes._
import scalafx.application.Platform
import scalafx.geometry.{Insets, Pos}
import scalafx.scene.control.{Button, TextArea, Tooltip}
import scalafx.scene.input.{Clipboard,DataFormat, KeyCode, KeyEvent, TransferMode}
import scalafx.scene.layout.{HBox, Priority, VBox}
import scalafx.scene.Parent
import scalafx.scene.text.Text // –ò—Å–ø–æ–ª—å–∑—É–µ–º Text –¥–ª—è —ç–º–æ–¥–∑–∏
import org.slf4j.LoggerFactory
import scala.util.{Try, Success, Failure} // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º Success –∏ Failure
import java.io.File // –î–ª—è Drag & Drop –∏ –Ω–æ–≤—ã—Ö –∫–æ–ª–±—ç–∫–æ–≤
import scala.jdk.CollectionConverters._ // –î–ª—è —Ä–∞–±–æ—Ç—ã —Å Java –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏ –∏–∑ Clipboard
import javafx.scene.image.Image // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º JavaFX Image –¥–ª—è –∫–æ–ª–±—ç–∫–∞

/**
 * –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (Footer) –¥–ª—è –≤–≤–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —ç–º–æ–¥–∑–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π –∏ —É–ª—É—á—à–µ–Ω–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É Drag & Drop.
 *
 * @param onSend             Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å" –∏–ª–∏ Enter. –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞.
 * @param onNewTopic         Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ "–ù–æ–≤—ã–π —Ç–æ–ø–∏–∫".
 * @param onAttachFileClick  Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ *–Ω–∞–∂–∞—Ç–∏–∏* –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–∞–π–ª" (–æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥).
 * @param onAttachCodeClick  Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ *–Ω–∞–∂–∞—Ç–∏–∏* –∫–Ω–æ–ø–∫–∏ "–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∫–æ–¥/–ø–∞–ø–∫—É" (–æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥).
 * @param onFileDropped      Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ *–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏* —Ñ–∞–π–ª–∞ –Ω–∞ –æ–±–ª–∞—Å—Ç—å –≤–≤–æ–¥–∞. –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –æ–±—ä–µ–∫—Ç File.
 * @param onDirectoryDropped Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ *–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏* –ø–∞–ø–∫–∏ –Ω–∞ –æ–±–ª–∞—Å—Ç—å –≤–≤–æ–¥–∞. –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –æ–±—ä–µ–∫—Ç File (–ø–∞–ø–∫—É).
 * @param onImagePasted      Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞. –ü—Ä–∏–Ω–∏–º–∞–µ—Ç javafx.scene.image. Image.
 */
class Footer(
              onSend: String => Unit,
              onNewTopic: () => Unit,
              // –ö–æ–ª–±—ç–∫–∏ –¥–ª—è –ö–õ–ò–ö–û–í –ø–æ –∫–Ω–æ–ø–∫–∞–º
              onAttachFileClick: () => Unit,
              onAttachCodeClick: () => Unit,
              // –ö–æ–ª–±—ç–∫–∏ –¥–ª—è Drag & Drop
              onFileDropped: File => Unit,
              onDirectoryDropped: File => Unit,
              // –ù–û–í–´–ô –∫–æ–ª–±—ç–∫ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
              onImagePasted: Image => Unit
            ) {

  private val logger = LoggerFactory.getLogger(getClass)

  // --- UI –≠–ª–µ–º–µ–Ω—Ç—ã ---

  private lazy val inputTextArea = new TextArea {
    promptText = "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª—ã/–ø–∞–ø–∫–∏..."
    prefRowCount = 3
    hgrow = Priority.Always
    wrapText = true
    id = "inputTextArea"

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ Enter
    onKeyPressed = (event: KeyEvent) => {
      if (event.code == KeyCode.Enter && !event.shiftDown) {
        event.consume()
        if (!disable.value) {
          val textToSend = text.value.trim
          if (textToSend.nonEmpty) onSend(textToSend)
          else logger.warn("Attempted to send empty input via Enter key.")
        } else {
          logger.trace("Enter pressed but input is disabled.")
        }
      }
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å—Ç–∞–≤–∫–∏ (Ctrl+V/Cmd+V) - –≤—ã–∑—ã–≤–∞–µ–º –Ω–∞—à –∫–∞—Å—Ç–æ–º–Ω—ã–π –º–µ—Ç–æ–¥
      else if ((event.controlDown || event.metaDown) && event.code == KeyCode.V) {
        event.consume() // –ü–æ—Ç—Ä–µ–±–ª—è–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ –≤—Å—Ç–∞–≤–∫–∏
        if (!disable.value) {
          pasteFromClipboard() // –í—ã–∑—ã–≤–∞–µ–º –Ω–∞—à—É –ª–æ–≥–∏–∫—É –≤—Å—Ç–∞–≤–∫–∏
        } else {
          logger.trace("Paste shortcut used but input is disabled.")
        }
      }
    }

    // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ Drag & Drop ---
    onDragOver = event => {
      if (event.gestureSource != this && event.dragboard.hasFiles) {
        event.acceptTransferModes(TransferMode.CopyOrMove*)
      }
      event.consume()
    }

    onDragDropped = event => {
      val db = event.dragboard
      var success = false
      if (db.hasFiles) {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º Java List –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ Scala List
        val files: List[File] = Option(db.getFiles).map(_.asScala.toList).getOrElse(List.empty)
        files.headOption.foreach { file =>
          logger.info(s"Element dropped: ${file.getAbsolutePath}")
          if (file.isDirectory) {
            logger.debug("Dropped element is a directory. Calling onDirectoryDropped.")
            onDirectoryDropped(file)
          } else {
            logger.debug("Dropped element is a file. Calling onFileDropped.")
            onFileDropped(file)
          }
          success = true
        }
      }
      event.dropCompleted = success
      event.consume()
    }
    // --- –ö–æ–Ω–µ—Ü –û–±—Ä–∞–±–æ—Ç–∫–∏ Drag & Drop ---
  }

  private lazy val sendButton = new Button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å") {
    tooltip = Tooltip("–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å (Enter)")
    prefWidth = 100
    styleClass.add("send-button")
    onAction = _ => {
      if (!disable.value) {
        val textToSend = inputTextArea.text.value.trim
        if (textToSend.nonEmpty) onSend(textToSend)
        else logger.warn("Send button clicked with empty input.")
      } else {
        logger.trace("Send button clicked but it's disabled.")
      }
    }
    disable = false
  }

  /**
   * –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–Ω–æ–ø–æ–∫ —Å –≠–ú–û–î–ó–ò.
   */
  private def createEmojiButton(emoji: String, tooltipText: String, action: () => Unit): Button = {
    new Button {
      graphic = new Text(emoji) { style = "-fx-font-size: 16px;" }
      style = "-fx-background-color: transparent; -fx-padding: 5px;"
      tooltip = Tooltip(tooltipText)
      onAction = _ => if (!disable.value) action()
      styleClass.add("emoji-button")
      disable = false
    }
  }

  private lazy val newTopicButton = createEmojiButton("‚ûï", "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥", onNewTopic)
  private lazy val attachFileButton = createEmojiButton("üìé", "–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª (–æ—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥)", onAttachFileClick)
  private lazy val attachCodeButton = createEmojiButton("üìÅ", "–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–∞–ø–∫–∏ (–æ—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥)", onAttachCodeClick)

  // –°–ø–∏—Å–æ–∫ –∫–æ–Ω—Ç—Ä–æ–ª–æ–≤ –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
  private lazy val lockableControls: Seq[javafx.scene.Node] = Seq(
    inputTextArea, sendButton, newTopicButton, attachFileButton, attachCodeButton
  )

  /**
   * –°–æ–∑–¥–∞–µ—Ç –∫–æ—Ä–Ω–µ–≤–æ–π —É–∑–µ–ª (Parent) –¥–ª—è –ø–∞–Ω–µ–ª–∏ Footer.
   */
  def createFooterNode(): Parent = {
    val controlButtonsBox = new VBox {
      spacing = 5
      alignment = Pos.TopRight
      children = Seq(
        sendButton,
        new HBox(2, newTopicButton, attachFileButton, attachCodeButton) { alignment = Pos.CenterRight }
      )
    }
    new HBox {
      padding = Insets(10)
      spacing = 10
      children = Seq(inputTextArea, controlButtonsBox)
      alignment = Pos.BottomLeft
      styleClass.add("footer-area")
    }
  }

  /** –û—á–∏—â–∞–µ—Ç –ø–æ–ª–µ –≤–≤–æ–¥–∞. */
  def clearInput(): Unit = Platform.runLater {
    inputTextArea.text = ""
    logger.debug("Footer input area cleared.")
  }

  /** –î–æ–±–∞–≤–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞. */
  def appendText(text: String): Unit = Platform.runLater {
    inputTextArea.appendText(text)
    inputTextArea.positionCaret(inputTextArea.text.value.length)
    inputTextArea.requestFocus()
    logger.debug("Text appended to footer input area.")
  }

  /** –ë–ª–æ–∫–∏—Ä—É–µ—Ç/—Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è. */
  def setLocked(locked: Boolean): Unit = Platform.runLater {
    lockableControls.foreach(_.disable = locked)
    val opacity = if (locked) 0.6 else 1.0
    lockableControls.foreach(_.opacity = opacity)
    logger.trace(s"Footer controls locked: $locked")
  }

  /**
   * –í—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏–∑ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö.
   * –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –¢–µ–∫—Å—Ç > –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ > –§–∞–π–ª—ã > HTML > RTF.
   * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Try –∏ match –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏.
   * –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–ª–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ match –¥–ª—è Try(clipboard.image).
   */
  def pasteFromClipboard(): Unit = {
    val clipboard = Clipboard.systemClipboard
    logger.debug("Attempting paste from clipboard. Available formats: {}", clipboard.contentTypes.mkString(", "))

    // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¢–ï–ö–°–¢
    Try(clipboard.getContent(DataFormat.PlainText)) match {
      case Success(content) if content != null && content.isInstanceOf[String] =>
        val textToPaste = content.asInstanceOf[String]
        if (textToPaste.nonEmpty) {
          inputTextArea.insertText(inputTextArea.caretPosition.value, textToPaste)
          logger.info("Pasted TEXT from clipboard into input area.")
          return
        } else {
          logger.debug("Clipboard contains an empty string.")
        }
      case Success(null) => logger.trace("Clipboard returned null for PLAIN_TEXT.")
      case Success(other) => logger.warn(s"Clipboard returned unexpected type for PLAIN_TEXT: ${other.getClass.getName}")
      case Failure(e) => logger.warn(s"Error getting PLAIN_TEXT from clipboard: ${e.getMessage}")
    }

    // 2. –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –Ω–µ –≤—Å—Ç–∞–≤–ª–µ–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ï
    if (clipboard.hasImage) {
      Try(clipboard.image) match {
        case Success(image) => // image is of type javafx.scene.image.Image (nullable)
          if (image != null) {
            logger.info(s"Pasted IMAGE from clipboard (size: ${image.width()}x${image.height()}). Calling onImagePasted callback.")
            onImagePasted(image)
            Platform.runLater {
              val placeholder = s"\n[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (${image.width()}x${image.height()}) –≤—Å—Ç–∞–≤–ª–µ–Ω–æ –∏ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å –∑–∞–ø—Ä–æ—Å–æ–º]\n"
              inputTextArea.insertText(inputTextArea.caretPosition.value, placeholder)
            }
            return // Image processed, exit
          } else {
            logger.debug("Clipboard hasImage is true, but clipboard.image returned null.")
          }
        case Failure(e) =>
          logger.warn(s"Error getting IMAGE from clipboard: ${e.getMessage}")
      }
    }

    // 3. –ï—Å–ª–∏ –Ω–µ —Ç–µ–∫—Å—Ç –∏ –Ω–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –ø—Ä–æ–≤–µ—Ä—è–µ–º –§–ê–ô–õ–´
    if (clipboard.hasFiles) {
      Try(Option(clipboard.getFiles).map(_.asScala.toList).getOrElse(List.empty)) match {
        case Success(files) if files.nonEmpty =>
          files.headOption.foreach { file =>
            logger.info(s"Pasted FILES from clipboard (${files.size} files). Processing first element: ${file.getAbsolutePath}")
            if (file.isDirectory) onDirectoryDropped(file) else onFileDropped(file)
            Platform.runLater {
              val placeholder = s"\n[–í—Å—Ç–∞–≤–ª–µ–Ω ${if(file.isDirectory)"–∫–∞—Ç–∞–ª–æ–≥" else "—Ñ–∞–π–ª"}: ${file.getName}]\n"
              inputTextArea.insertText(inputTextArea.caretPosition.value, placeholder)
            }
          }
          return
        case Success(_) => logger.warn("Clipboard has files, but the list is empty.")
        case Failure(e) => logger.warn(s"Error getting FILES from clipboard: ${e.getMessage}")
      }
    }

    // 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º HTML
    Try(clipboard.getContent(DataFormat.Html)) match {
      case Success(content) if content != null && content.isInstanceOf[String] =>
        val htmlContent = content.asInstanceOf[String]
        if (htmlContent.nonEmpty) {
          logger.info("Pasted HTML from clipboard. Processing not implemented yet. Content starts with: {}", htmlContent.take(100))
          Platform.runLater {
            inputTextArea.insertText(inputTextArea.caretPosition.value, "[–í—Å—Ç–∞–≤–ª–µ–Ω HTML –∫–æ–Ω—Ç–µ–Ω—Ç (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞)]")
          }
          return
        } else { logger.debug("Clipboard contains empty HTML.") }
      case Success(null) => logger.trace("Clipboard returned null for HTML.")
      case Success(other) => logger.warn(s"Clipboard returned unexpected type for HTML: ${other.getClass.getName}")
      case Failure(e) => logger.warn(s"Error getting HTML from clipboard: ${e.getMessage}")
    }

    // 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º RTF
    Try(clipboard.getContent(DataFormat.Rtf)) match {
      case Success(content) if content != null && content.isInstanceOf[String] =>
        val rtfContent = content.asInstanceOf[String]
        if (rtfContent.nonEmpty) {
          logger.info("Pasted RTF from clipboard. Processing not implemented yet.")
          Platform.runLater {
            inputTextArea.insertText(inputTextArea.caretPosition.value, "[–í—Å—Ç–∞–≤–ª–µ–Ω RTF –∫–æ–Ω—Ç–µ–Ω—Ç (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞)]")
          }
          return
        } else { logger.debug("Clipboard contains empty RTF.") }
      case Success(null) => logger.trace("Clipboard returned null for RTF.")
      case Success(other) => logger.warn(s"Clipboard returned unexpected type for RTF: ${other.getClass.getName}")
      case Failure(e) => logger.warn(s"Error getting RTF from clipboard: ${e.getMessage}")
    }

    logger.warn("Clipboard contains content, but not in a currently supported/prioritized format for pasting (String, Image, Files, HTML, RTF).")
  }
}