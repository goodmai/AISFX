# Анализ Структуры и Функционала Приложения

На основе анализа кода и логов, текущая структура и функционал приложения описываются следующим образом:

## Структура Проекта (Packages)

* **`com.aiplatform.app`**: Точка входа (`MainApp.scala`). Инициализирует контроллер, UI и систему акторов Pekko.
* **`com.aiplatform.controller`**:
    * `MainController.scala`: Центральный координатор. Обрабатывает UI события (от `Header`, `Footer`, `HistoryPanel`, `SettingsView`), управляет жизненным циклом приложения, вызывает менеджеры для выполнения операций, синхронизирует UI с состоянием `AppState`.
    * `manager/`: Пакет с менеджерами для разделения логики:
        * `StateManager.scala`: Управляет `AppState`, обеспечивает потокобезопасный доступ и сохранение/загрузку через `StateRepository`.
        * `TopicManager.scala`: Логика создания, удаления, поиска, обновления топиков и диалогов, включая генерацию заголовков.
        * `PresetManager.scala`: Управляет стандартными и пользовательскими пресетами, а также их назначением кнопкам категорий.
        * `RequestExecutionManager.scala`: Инкапсулирует сложную логику выполнения AI запроса: определяет/создает топик, выбирает пресет/модель, формирует историю, вызывает `AIService`, обрабатывает результат, инициирует обновление состояния (добавление диалога, генерация заголовка).
        * `FileManager.scala`: Управляет взаимодействием с файловой системой для прикрепления файлов/папок через `Footer`.
* **`com.aiplatform.model`**: Определения структур данных:
    * `AppState.scala`: Корневое состояние приложения.
    * `FileTreeContext.scala`: Контекст выбранных файлов из дерева файлов.
    * `FileSelectionState.scala`: Состояние отдельного файла в контексте дерева файлов (успешно выбран, ошибка).
    * `Topic.scala`: Модель топика (диалога).
    * `Dialog.scala`: Модель одного обмена (запрос-ответ).
    * `PromptPreset.scala`: Модель пресета промпта.
    * `ModelInfo.scala`: Информация о доступных AI моделях.
    * `Section.scala`: (Не используется активно в текущей логике).
* **`com.aiplatform.repository`**:
    * `StateRepository.scala`: Отвечает за сериализацию/десериализацию `AppState` в/из JSON файла (`app_state.json`).
* **`com.aiplatform.service`**: Сервисы для взаимодействия с внешним миром:
    * `AIService.scala`: Взаимодействует с Google Generative AI API (Gemini) для выполнения запросов. Использует Pekko HTTP.
    * `CredentialsService.scala`: Безопасное хранение API ключа с использованием `java.util.prefs.Preferences`.
    * `ModelFetchingService.scala`: Загружает список доступных моделей AI от API.
    * `HistoryService.scala`: (Используется только для инициализации `ActorSystem`, основная логика истории управляется `TopicManager` и `StateManager`).
* **`com.aiplatform.util`**:
    * `JsonUtil.scala`: Утилиты для сериализации/десериализации uPickle, включая кастомный `ReadWriter` для `Instant`.
* **`com.aiplatform.view`**: Компоненты пользовательского интерфейса (ScalaFX):
    * `Header.scala`: Верхняя панель с кнопками категорий и настроек.
    * `HistoryPanel.scala`: Левая панель со списком топиков текущей категории.
    * `ResponseArea.scala`: Центральная область для отображения диалога (запросов и ответов), включая форматирование кода.
    * `Footer.scala`: Нижняя панель с полем ввода запроса и кнопками управления (Отправить, Новый топик, Прикрепить файл/папку).
    * `SettingsView.scala`: Модальное окно настроек приложения (API ключ, модель, шрифт, пресеты, назначения).
    * `DialogUtils.scala`: (Внутри `SettingsView`) Утилиты для стандартных диалоговых окон (ошибка, предупреждение, подтверждение).

## Основной Функционал

1.  **Управление состоянием:** Централизовано в `StateManager` с сохранением/загрузкой в JSON через `StateRepository`. Обновления состояния атомарны. Логи подтверждают успешное сохранение состояния после исправлений.
2.  **Взаимодействие с AI:**
    * Выполняется через `AIService`, который инкапсулирует вызовы к Gemini API.
    * `RequestExecutionManager` оркестрирует процесс: подготовка данных, вызов сервиса, обработка ответа, обновление состояния.
    * Поддерживается выбор модели AI (глобально и через пресеты).
    * Список моделей загружается через `ModelFetchingService`.
    * API ключ хранится безопасно (`CredentialsService`).
3.  **Управление Топиками/Диалогами:**
    * Логика сосредоточена в `TopicManager`.
    * Создание, удаление, добавление диалогов.
    * Автоматическая генерация заголовка для новых топиков.
    * `HistoryPanel` отображает список топиков для *активной* категории.
    * Поддерживается переключение между топиками и категориями, но требует оптимизации для UI (см. TODO).
4.  **Управление Пресетами:**
    * Логика в `PresetManager`.
    * Разделение на стандартные и пользовательские пресеты.
    * Редактирование, добавление, удаление пользовательских пресетов через `SettingsView`.
    * Назначение пресетов кнопкам категорий.
5.  **Пользовательский Интерфейс:**
    * Построен на ScalaFX.
    * Четкое разделение на компоненты (`Header`, `HistoryPanel`, `ResponseArea`, `Footer`).
    * `ResponseArea` корректно отображает диалоги, включая форматирование кода. Логи подтверждают успешное добавление запросов/ответов.
    * `Footer` предоставляет поле ввода и кнопки управления.
    * `SettingsView` позволяет настраивать ключевые параметры.
    * Поддерживается настройка шрифта.

## Резюме Анализа

Приложение имеет хорошо структурированную архитектуру с разделением ответственности. Основные функции реализованы. Критический баг с сохранением состояния после создания топика, похоже, исправлен, судя по логам.

**Текущие Основные Проблемы:**

1.  **Стабильность UI:** Частое переключение активного топика (между `None` и ID) и избыточная перерисовка `ResponseArea` при выборе топика в `HistoryPanel`, что приводит к визуальным артефактам и отображению сообщения "Выберите топик...".
2.  **Отсутствие блокировки UI:** Нет механизма, предотвращающего отправку нового запроса до получения ответа на предыдущий.
3.  **Проблемы при запуске (потенциальные):** Возможная ошибка десериализации `app_state.json` и отсутствие файлов иконок (требует проверки).

**Необходимо сосредоточиться на:**

* Оптимизации логики обновления UI при смене активного топика/категории.
* Реализации блокировки UI во время выполнения AI запроса.
* Проверке и исправлении проблем, возникающих при запуске приложения (десериализация состояния, загрузка ресурсов).